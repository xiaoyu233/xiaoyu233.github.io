{"pages":[{"title":"About","text":"搬砖中.jpg、xiaoyu的日记 很开心遇见你（´v｀）","link":"/about/index.html"}],"posts":[{"title":"Aosp编译","text":"自从年少无知（′д｀ ）掉进了Android开发的坑后，就一直想编译一波Aosp，无奈通过我大局域网拉取那几十G的Android源码，实在过于梦幻。在一开始看教程，还尝试从清华镜像源拉取源码，但可能是他们钞能力不够了吧，每次同步一会儿就嗝屁了。 不过即使我把代码拉下来了，我原先那渣渣配置笔记本来编译怕不是要原地上天呀（ ‵▽′）ψ。 直到最近自己配了台式，性能上比笔记本高到不知道那里去了。后面又花了30大洋巨资买了个梯子，直接拉谷歌服务器上的源码，不快但比较稳定，毕竟跑的快不一定成功嘛(～￣▽￣)～，可以开始编译编译啦。 首先是编译环境的选择，自己现在使用黑苹果，看教程也有使用苹果系统进行编译的，不过似乎因为文件系统的原因，需要创建一个新的分区挂载，在新分区中进行编译工作。想想操作越多越可能出错，就选择Ubuntu Server 18.04作为编译环境。 12345678910111213141516171819202122232425262728# installl jdksudo apt-get updatesudo apt-get install openjdk-8-jdkjava -version# install the necessary toolssudo apt-get install bison g++-multilib git gperf libxml2-utils make zlib1g-dev:i386 zip liblz4-tool libncurses5 libssl-dev bc flex# Download Repomkdir ~/bincurl http://commondatastorage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repoexport PATH=~/bin:$PATH# Download the Aospmkdir ~/androidcd ~/androidrepo init -u https://android.googlesource.com/platform/manifest -b &lt;branch&gt;export http_proxy=http://xxxx.xxx:portexport https_proxy=http://xxxx.xxx:portrepo sync# Build Aosp imagessource build/envsetup.sh# Select the target deviceslunch# Start the buildmake -j&amp;(nproc) 我的编译过程总体还算比较顺利，失败几次后编译成功了，还好没有卡住。说一说我遇到的坑吧。 资源问题这个问题很好发现排查，在编译过程中可以新开一个窗口，运行atop查看系统资源使用情况。在经历两次内存不足而导致编译进程被杀后，将内存调整至10G（宿主机总内存16G）并分配10G的Swap，顺便将编译的线程数降低，再次编译可以通过前期大部分系统底层编译至末尾Framework层编译，没有发现进程被杀现象。 python版本问题在编译之前我想都0202年了，应该不需要用python2.7了吧，想来我还是too young, too simple，前面解决系统资源问题后，日志显示编译工作已经完成，但在打包镜像的过程中失败了。 123print &quot;'%s' cannot be converted to int&quot; % (line[2]) ^SyntaxError: invalid syntax 错误定位在mk_combined_img.py中 12345try: partition_info[&quot;num&quot;] = int(line[2])except ValueError: print &quot;'%s' cannot be converted to int&quot; % (line[2]) sys.exit(1) 功能似乎是根据配置文件system-qemu-config.txt 12out/target/product/generic_x86/vbmeta.img vbmeta 1out/target/product/generic_x86/super.img super 2 生成system-qemu.img，内部调用sgdisk工具。 不过从出错的函数看，应该与该文件主功能关联不大，应该不是sgdisk工具的问题。 这时已经在两次完整编译后晚上1点过了，想想还是不修仙了。 第二天，又尝试了几次，还是不行，突然想到会不会与python版本有关，自己呢对这胶水语言又不是很熟悉，就把之前出错的函数抽来，用python2.7和python3.6测试，结果 123456~/Desktop$ python2 test.py ~/Desktop$ python3 test.py File &quot;test.py&quot;, line 32 print &quot;'%s' cannot be converted to int&quot; % (line[2]) ^SyntaxError: invalid syntax 总结总之，这次编译Aosp总算完成了，编译了X86的镜像，后面试试可以运行不。 接触Android开发只有一年多点，技术总在不断变化中，Jatpack MVVM、Flutter以及将来的Jatpack Compose，有时总担心自己一回头发现自己总写业务，留自己的东西太少。所以嘛(。・_・)/希望这次是一个好的开端，更多地探索为什么。","link":"/2020/05/05/aosp-build/"},{"title":"搭建CodiMD","text":"对于记笔记，之前一直用的是Trilium Notes，虽然支持markdown文档，但编写体验并不好； 对markdown支持不好，对markdown没有任何预览功能 对Trilium Notes的UI风格不是很感冒 我理想编辑器至少应该有markdown支持良好、整体UI比较简洁扁平、支持在线保存、可以随时编辑等特性 另外出于隐私和数据安全的考虑，我并不想使用市面上的各种在线笔记应用，虽然有些笔记编写体验着实不错，但国内公司提供的服务说不定什么时候就无了，还有无时无刻的审查，说不定就像百度网盘变教育片了，所以对于我笔记应用必须是能够自托管的。 在github一番搜索，最终发现了CodiMD CodiMD可以让你使用markdown编写文档，由HackMD源代码构建，可以看作HackMD的开源版本 在尝试了一下CodiMD的演示应用，第一次编写体验不错，UI简单明了，markdown的预览支持自动滚动、主题还行，并且支持在线保存 于是开心地决定使用CodiMD作为主力笔记。（´v｀） 拿起我的Chrome，输入CodiMD docker hub，发现linuxserver有发布CodiMD的镜像，emmmmm 就他家的镜像linuxserver/codimd吧。 1234567891011121314docker create \\ --name=codimd \\ -e PUID=1000 \\ -e PGID=1000 \\ -e DB_HOST=hostname or ip \\ -e DB_PORT=3306 \\ -e DB_USER=codimd \\ -e DB_PASS=secret password \\ -e DB_NAME=codimd \\ -e TZ=Europe/London \\ -p 3000:3000 \\ -v /path/to/appdata:/config \\ --restart unless-stopped \\ linuxserver/codimd 发现要搭配mariadb数据库，那就在拉取一下mariadb镜像 1docker pull linuxserver/mariadb 先创建一个docker network方便两个容器通信 1docker network create codimd 启动mariadb数据库 1234567891011121314151617#! /bin/bashmariadb_config=$CACHE/Data/Codimd/databasedocker run \\ --rm -d \\ --name=codimd_mariadb \\ --network=codimd \\ -e PUID=1000 \\ -e PGID=1000 \\ -e MYSQL_ROOT_PASSWORD=codimd \\ -e TZ=Asia/Shanghai \\ -v $mariadb_config:/config \\ -e MYSQL_DATABASE=USER_DB_NAME `#optional` \\ -e MYSQL_USER=MYSQL_USER `#optional` \\ -e MYSQL_PASSWORD=DATABASE_PASSWORD `#optional` \\ linuxserver/mariadb 在启动CodiMD，通过logs查看一下容器启动情况。 1docker logs -f codimd 在看到Listen 0.0.0.0:3000之后，开心地打开浏览器输入地址 本来在这里就结束了的，然后我在使用CodiMD编辑的时候，发现输入中文就会报404，日志上显示Incorrect string value 搜索一下，似乎是mariadb默认配置不支持插入中文字符 解决方法是在maradb启动的之前，修改/config/custom.cnf文件，新增 1234567[mysqld]collation-server = utf8_unicode_ciinit-connect='SET NAMES utf8'character-set-server = utf8[mysql]default-character-set=utf8 之后使用命令建库 1234create database codimd;CREATE USER 'codimd'@'%' IDENTIFIED BY 'yourpassword';GRANT ALL PRIVILEGES ON codimd.* TO 'codimd'@'%';FLUSH PRIVILEGES; 最后启动在CodiMD，就可以输入中文了。╰(￣▽￣)╭","link":"/2020/07/18/build-codimd/"},{"title":"EXSI断电关机脚本","text":"新建关机脚本vi /vmfs/volumes/[YOUR DRIVE]/scripts/ups/nic.sh 1234567891011#! /bin/shnic_stat=`esxcfg-nics -l | grep vmnic0 | awk '{print $4}'`if [ &quot;$nic_stat&quot; == &quot;Down&quot; ];then sleep 100 if [ &quot;$nic_stat&quot; == &quot;Down&quot; ];then sleep 100 if [ &quot;$nic_stat&quot; == &quot;Down&quot; ];then /sbin/poweroff fi fifi 我的交换机是没有接ups的，所以在断电时交换机关机，exsi的网卡状态是down。 定时检查网卡状态，如果连续几次检测网卡下线，那么就执行关机命令。 添加脚本到cron如果手动将脚本添加定时任务/var/spool/cron/crontabs/root，当EXSI重启之后定时任务是会被清除的。 所以需要通过开机脚本添加定时任务。 vi /etc/rc.local.d/local.sh 123456#!/bin/sh/bin/chmod +w /var/spool/cron/crontabs/root/bin/kill $(cat /var/run/crond.pid)/bin/echo '*/5 * * * * /vmfs/volumes/[YOUR DRIVE]/scripts/ups/nic.sh' &gt;&gt; /var/spool/cron/crontabs/root/bin/crondexit 0 最后重启EXSI服务器就好了。(￣▽￣)","link":"/2021/03/28/exsi-auto-shutdown/"},{"title":"EXSI显卡直通","text":"之前一直想折腾虚拟机硬件直通，最先尝试过pve和unraid系统，无奈都失败了，pve下直通硬件操作好繁琐，加上自己姿势不够，所以一直在死机( ｀д′)。unraid系统上硬件的分组总是有问题，进行隔离后就开不了机了w(ﾟДﾟ)w，最后在ESXI系统上实现了硬件直通 先罗列一下硬件吧。 CPU: R5 3600 Motherboard: MSI B450m GPU1: HD 7450 GPU2: R5 240 SSD: SN750 显卡都是用来测试的亮机卡，其中R5 240是用来测试直通的显卡 显卡直通本身依赖许多功能 CPU必须支持硬件虚拟化和IOMMU（Intel VT-d 和 AMD-Vi 的通用名称） 主板必须支持IOMMU 分配给客户机的GPU的ROM必须支持UEFI 安装ESXIESXI是VMware公司提供的服务器系统，ESXI兼容的硬件有限，尤其在网卡方面。好在已经有工具可以添加对应网卡驱动并重新打包ESXI的镜像 驱动下载地址，根据自己的网卡型号下载驱动即可 在定制镜像之后，安装过程比较简单无脑下一步 之后在网上随便搜一个ESXI的许可证填上，过期时间就变成永久了 直通显卡在Manage-&gt;Hardware-&gt;PCI Devices中将选中硬件并切换直通，然后重启ESXI系统，之后对应硬件Passthrough就变为active 创建虚拟机，选择ESXI 6.7 U2 virtual machine，内存需要勾选Reserve all guest memory(All locked)，添加PCI devices，将GPU和GPU Audio都添加给虚拟机 最后启动虚拟机进行系统安装即可 因为好久没写博客了，所以水一篇拔一下草。如果想尝试虚拟机硬件直通，建议先简单了解一下理论上的东西并且对自己的硬件有足够的了解，可以规避很多不必要坑，_(:3 」∠ )_避免生命的流逝.jpg。","link":"/2020/11/25/gpu-passthrough/"},{"title":"hello world","text":"很开心与你相遇~","link":"/2020/01/01/hello-world/"},{"title":"添置ups","text":"今天在公司想访问家里nas上的文件，发现nas访问不了，ssh也连不上。Σ(っ °Д °;)っ 想想可能是电信宽带自动换ip了，等十几分钟nas上自动运行更新动态域名的脚本，把域名指向变更后的ip，应该就可以访问了。 果然过了十几分钟后，再次尝试使用ssh连接，成功连接，但是我在查看域名更新脚本的日志时，并没有发现更改过域名指向，而且我那十几个docker容器也全部停止了。 那应该不是ip变了，是停电了。╥﹏╥… 想起来在小区电网改造之前，停电次数更多，改造之后还是会间隙性停电，老小区就是毛病多啊。这样突然停电次数多了，nas的硬盘怕是遭不住啊。 所以还是决定买台ups，保护一下吧。 因为长期运行的设备就只有那个nas，所以就选了那种功能比较简单、容量也比较低的，两百来块吧。 到手后，就只将nas接到ups上，然后在nas写一个脚本，定时ping一下网关也就是路由器，如果失败了，就运行关机命令。 123456789#!/bin/sh/bin/ping -c5 192.168.2.1if [ $? -eq 0 ]; then /bin/echo &quot;ping successfully&quot;else /sbin/shutdown -h nowfi 运行 1234567891011PING 192.168.2.1 (192.168.2.1) 56(84) bytes of data.64 bytes from 192.168.2.1: icmp_seq=1 ttl=64 time=0.840 ms64 bytes from 192.168.2.1: icmp_seq=2 ttl=64 time=0.457 ms64 bytes from 192.168.2.1: icmp_seq=3 ttl=64 time=0.596 ms64 bytes from 192.168.2.1: icmp_seq=4 ttl=64 time=0.349 ms64 bytes from 192.168.2.1: icmp_seq=5 ttl=64 time=0.436 ms--- 192.168.2.1 ping statistics ---5 packets transmitted, 5 received, 0% packet loss, time 4104msrtt min/avg/max/mdev = 0.349/0.535/0.840/0.173 msping successfully 手动断电模拟一下，过几分钟可以自动关机，好的，基本功能实现了，后面路由器再配置一下远程开机就完工了。φ(゜▽゜*)♪ 另外这个ups的信息倒是挺友好的，负载、输入输出电压、电池状态都挺清楚的。","link":"/2020/06/13/nas-ups/"},{"title":"Restic阿里云OSS备份数据","text":"之前一直将文件放在自己搭建的Nas中，总是担心万一Nas的硬盘坏掉了，那我的数据就没了呀。 最后还是考虑加上异地备份，因为我的数据主要为文档和图片，占用的空间不大，大概就两三个g吧，所以选用了阿里云的对象储存。 备份工具选用的是Restic，是一款Go语言开发的开源跨平台备份工具，使用加密技术来保证数据安全性和完整性，可以将本地数据加密后传输到指定的存储，并且支持阿里云OSS。 加密后备份就非常符合我的需求，我可不想直接将文件同步到阿里云OSS，因为阿里云OSS同时还被我当图床用，设置了公共读权限。 获取阿里云OSS的AccessKey这里尽量不用主账号生成AccessKey，可以用阿里云的RAW访问控制，通过新建子用户并只分配对应的权限来访问资源，更安全一些。 初始化Restic备份仓库设置AccessKey 12export AWS_ACCESS_KEY_ID=&lt;YOUR-OSS-ACCESS-KEY-ID&gt;export AWS_SECRET_ACCESS_KEY=&lt;YOUR-OSS-SECRET-ACCESS-KEY&gt; 在OSS上初始化仓库 1restic -o s3.bucket-lookup=dns -o s3.region=&lt;OSS-REGION&gt; -r s3:https://&lt;OSS-ENDPOINT&gt;/&lt;OSS-BUCKET-NAME&gt; init 栗子 1234restic -o s3.bucket-lookup=dns \\ -o s3.region=oss-cn-shenzhen \\ -r s3:https://oss-cn-shenzhen.aliyuncs.com/&lt;Bucket&gt; \\ init 这里会要求设置备份密码，尽量复杂一些。 可以将密码写入文本文件，以后访问备份仓库的时候就不用输密码了。 1echo '&lt;YOUR PASSWORD&gt;' &gt; ./shadow 初始化后OSS上会有对应文件。 备份本地数据1234567891011#! /bin/bashexport AWS_ACCESS_KEY_ID=&lt;YOUR-OSS-ACCESS-KEY-ID&gt;export AWS_SECRET_ACCESS_KEY=&lt;YOUR-OSS-SECRET-ACCESS-KEY&gt;restic -o s3.bucket-lookup=dns \\ -o s3.region=&lt;OSS-REGION&gt; \\ -r s3:&lt;OSS-ENDPOINT&gt;/&lt;OSS-BUCKET-NAME&gt; \\ backup &lt;YOUR LOCAL DATA DIR&gt; \\ --exclude &lt;NO BACKUP REQUIRED DIR&gt; \\ --password-file &lt;PASSWORD FILE&gt; 每次执行备份命令，Restic都会生成一个快照SnapShot，可以需要时回退到指定版本。 如果不需要保存所有快照，可以在备份后清理旧快照，并且可以只保留最近几次的快照。 12345678910#! /bin/bashexport AWS_ACCESS_KEY_ID=&lt;YOUR-OSS-ACCESS-KEY-ID&gt;export AWS_SECRET_ACCESS_KEY=&lt;YOUR-OSS-SECRET-ACCESS-KEY&gt;restic -o s3.bucket-lookup=dns \\ -o s3.region=&lt;OSS-REGION&gt; \\ -r s3:&lt;OSS-ENDPOINT&gt;/&lt;OSS-BUCKET-NAME&gt; \\ forget --keep-last 5 --prune \\ --password-file &lt;PASSWORD FILE&gt; 最后在添加一下定时任务，每天12:00执行一下备份命令。 这样一个定时的异地备份就完成啦。( ╹▽╹ ) 整个过程搭建还是比较快的，主要是这个开源的备份工具用起来很简单。","link":"/2021/05/13/restic-with-ali-oss/"}],"tags":[{"name":"aosp","slug":"aosp","link":"/tags/aosp/"},{"name":"notes","slug":"notes","link":"/tags/notes/"},{"name":"gpu-passthrough","slug":"gpu-passthrough","link":"/tags/gpu-passthrough/"},{"name":"ups","slug":"ups","link":"/tags/ups/"}],"categories":[]}